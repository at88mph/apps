package ca.nrc.cadc.dlm;import ca.nrc.cadc.dali.Shape;import ca.nrc.cadc.util.StringUtil;import java.net.URI;import java.net.URISyntaxException;import javax.swing.plaf.synth.Region;import org.apache.log4j.Logger;public class DownloadTuple {    private static final Logger log = Logger.getLogger(DownloadTuple.class);//    will be translated into URI when needed//    this format required for use in DownloadIterators    public String tupleID;//    public ParsedURI tupleID;    // unsure we need Region or not - only interesting    // in cadc-download-manager when DataLinkClient is putting    // together cutouts    private Region shape;    private String shapeDescriptor;    private String label;    public boolean isUploadFileTuple = false;    /** tupleID is the only required field (for now     *     * @param tupleID     *///    public DownloadTuple(URI tupleID) {//        this.tupleID = new ParsedURI(tupleID);//        this.shapeDescriptor = null;//        this.label = null;//    }   public DownloadTuple(URI tupleID) {//        this.tupleID = new ParsedURI(tupleID);//        this.shapeDescriptor = null;//        this.label = null;//    }    /** Alternate ctor if a string in the expected tuple format is provided.     *     * @param tupleStr     */    public DownloadTuple(String tupleStr) {        // optionally have this in a function - can't make the values final        // if it's not done in constructor though - TODO - decide if extra        // function is necessary        // split string on '{'        log.info("tuple string input: " + tupleStr);        String [] tupleParts = tupleStr.split("\\{");        // todo: add some validation after this is shown to work        if (tupleParts.length == 1) {            // is a URI only            tupleID = tupleParts[0];            this.shapeDescriptor = null;            this.label = null;        }        else if (tupleParts.length <= 2) {            // grab first [0] element as ID, translate to URI            // grab second [1] element as shape, chop last '}' and store in shapeDescriptor            this.tupleID = tupleParts[0];            this.shapeDescriptor = tupleParts[1];        }        else if (tupleParts.length == 3) {            // grab optional third [2] parameter as label            this.label = tupleParts[2];        } else {            this.label = null;        }    }    public String toOutputFormat() {        String tupleStr = tupleID;        // This function might be able to provide different formats        // within the shapeDescriptor to substitute whitespace for a different character        if (StringUtil.hasLength(shapeDescriptor)) {            tupleStr += "{" + shapeDescriptor + "}";        }        if (StringUtil.hasLength(label)) {            tupleStr += "{" + label + "}";        }        return tupleStr;    }    /**     * @param tupleStr     * expected format: ID{shape}{label}     *          where ID is a URI     *          shape is a Region     *          label is a String     */    public void parseOutputFormat(String tupleStr) {        // split string on '{'        String [] tupleParts = tupleStr.split("\\{");        System.out.println(tupleStr);        if (tupleParts.length == 1) {            // is a URI only            tupleID = tupleParts[0];            this.shapeDescriptor = null;            this.label = null;        }        else if (tupleParts.length <= 2) {            // grab first [0] element as ID, translate to URI            // grab second [1] element as shape, chop last '}' and store in shapeDescriptor            this.tupleID = tupleParts[0];            this.shapeDescriptor = tupleParts[1];        }        else if (tupleParts.length == 3) {            // grab optional third [2] parameter as label            this.label = tupleParts[2];        } else {            this.label = null;        }    }}